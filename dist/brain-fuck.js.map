{"version":3,"sources":["constants/index.js","utils/jump.js","brain-fuck.js"],"names":["MAX_CHAR_VALUE","EXTEND_SIZE","MEM_SIZE","jumpForward","program","_iptr","iptr","openBracketsCount","jumpBackward","closeBracketsCount","BrainFuck","input","memory","Array","fill","output","mptr","infinite","Error","t1","performance","now","length","concat","val","Math","ceil","String","fromCharCode","charCodeAt","slice","t2","compilationTime","module","exports"],"mappings":"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","file":"brain-fuck.js","sourceRoot":"../src","sourcesContent":["const MAX_CHAR_VALUE = 256;\nconst EXTEND_SIZE = 10;\nconst MEM_SIZE = 300; // 300 cells\n\nexport { MAX_CHAR_VALUE, EXTEND_SIZE, MEM_SIZE };\n","export function jumpForward (program, _iptr) {\n  let iptr = _iptr, openBracketsCount = 1;\n\n  while (openBracketsCount > 0) {\n    switch (program[++iptr]) {\n      case '[':\n        openBracketsCount++;\n        break;\n      case ']':\n        openBracketsCount--;\n    }\n  }\n\n  return iptr;\n}\n\nexport function jumpBackward (program, _iptr) {\n  let iptr = _iptr, closeBracketsCount = 1;\n\n  while (closeBracketsCount > 0) {\n    switch (program[--iptr]) {\n      case ']':\n        closeBracketsCount++;\n        break;\n      case '[':\n        closeBracketsCount--;\n    }\n  }\n\n  return iptr;\n}\n","import { MAX_CHAR_VALUE, EXTEND_SIZE, MEM_SIZE } from './constants/index';\nimport { jumpBackward, jumpForward } from './utils/jump';\n\nclass BrainFuck {\n  constructor (program, input) {\n    this.program = program;\n    this.memory = Array(MEM_SIZE).fill(0);\n    this.input = input || '';\n    this.output = '';\n    this.iptr = 0; // instruction pointer\n    this.mptr = 0; // memory pointer\n    this.infinite = false;\n  }\n\n  compile () {\n    if (!this.program) {\n      throw Error('nothing to compile');\n    }\n\n    const t1 = performance.now();\n\n    while (this.iptr < this.program.length) {\n      if (performance.now() - t1 > 20000) { // infinite detection, there might be a better way than this :)\n        this.infinite = true;\n        break;\n      }\n\n      switch (this.program[this.iptr]) {\n        case '>':\n          if (this.mptr >= this.memory.length - 1) {\n            this.memory = this.memory.concat(Array(EXTEND_SIZE).fill(0));\n          }\n\n          this.mptr++;\n          break;\n        case '<':\n          this.mptr = this.mptr - 1 < 0 ? this.mptr : this.mptr - 1;\n          break;\n        case '+':\n          this.memory[this.mptr] = (this.memory[this.mptr] + 1) % MAX_CHAR_VALUE;\n          break;\n        case '-':\n          let val = this.memory[this.mptr] - 1;\n\n          if (val < 0) {\n            val += MAX_CHAR_VALUE * (Math.ceil(-val / MAX_CHAR_VALUE))\n          }\n\n          this.memory[this.mptr] = val;\n          break;\n        case '.':\n          this.output += String.fromCharCode(this.memory[this.mptr]);\n          break;\n        case ',':\n          this.memory[this.mptr] = this.input.charCodeAt(0);\n\n          this.input = this.input.slice(1);\n          break;\n        case '[':\n          if (!this.memory[this.mptr]) {\n            this.iptr = jumpForward(this.program, this.iptr);\n          }\n          break;\n        case ']':\n          if (this.memory[this.mptr]) {\n            this.iptr = jumpBackward(this.program, this.iptr);\n          }\n          break;\n      }\n\n      this.iptr++;\n    }\n\n    const t2 = performance.now();\n\n    return {\n      program: this.program,\n      input: this.input,\n      output: this.output,\n      memory: this.memory,\n      compilationTime: t2 - t1,\n      infinite: this.infinite\n    };\n  }\n}\n\nmodule.exports = BrainFuck;\n"]}