{"version":3,"sources":["constants/index.js","utils/jump.js","brain-fuck.js"],"names":["MAX_CHAR_VALUE","EXTEND_SIZE","MEM_SIZE","jumpForward","program","_iptr","openBracketsCount","iptr","jumpBackward","closeBracketsCount","BrainFuck","input","memory","Array","fill","output","mptr","infinite","Error","t1","performance","now","length","concat","val","Math","ceil","String","fromCharCode","charCodeAt","slice","t2","compilationTime","module","exports"],"mappings":"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","file":"brain-fuck.js","sourceRoot":"../src","sourcesContent":["const MAX_CHAR_VALUE = 256;\nconst EXTEND_SIZE = 10;\nconst MEM_SIZE = 300; // 300 cells\n\nexport { MAX_CHAR_VALUE, EXTEND_SIZE, MEM_SIZE };\n","export function jumpForward (program, _iptr) {\n  let iptr = _iptr, openBracketsCount = 1;\n\n  while (openBracketsCount > 0) {\n    switch (program[++iptr]) {\n      case '[':\n        openBracketsCount++;\n        break;\n      case ']':\n        openBracketsCount--;\n    }\n  }\n\n  return iptr;\n}\n\nexport function jumpBackward (program, _iptr) {\n  let iptr = _iptr, closeBracketsCount = 1;\n\n  while (closeBracketsCount > 0) {\n    switch (program[--iptr]) {\n      case ']':\n        closeBracketsCount++;\n        break;\n      case '[':\n        closeBracketsCount--;\n    }\n  }\n\n  return iptr;\n}\n","import { MAX_CHAR_VALUE, EXTEND_SIZE, MEM_SIZE } from './constants/index';\nimport { jumpBackward, jumpForward } from './utils/jump';\n\nclass BrainFuck {\n  constructor (program, input) {\n    this.program = program;\n    this.memory = Array(MEM_SIZE).fill(0);\n    this.input = input || '';\n    this.output = '';\n    this.iptr = 0; // instruction pointer\n    this.mptr = 0; // memory pointer\n    this.infinite = false;\n  }\n\n  compile () {\n    if (!this.program) {\n      throw Error('nothing to compile');\n    }\n\n    const t1 = performance.now();\n\n    while (this.iptr < this.program.length) {\n      if (performance.now() - t1 > 20000) { // infinite detection, there might be a better way than this :)\n        this.infinite = true;\n        break;\n      }\n\n      switch (this.program[this.iptr]) {\n        case '>':\n          if (this.mptr >= this.memory.length - 1) {\n            this.memory = this.memory.concat(Array(EXTEND_SIZE).fill(0));\n          }\n\n          this.mptr++;\n          break;\n        case '<':\n          this.mptr = this.mptr - 1 < 0 ? this.mptr : this.mptr - 1;\n          break;\n        case '+':\n          this.memory[this.mptr] = (this.memory[this.mptr] + 1) % MAX_CHAR_VALUE;\n          break;\n        case '-':\n          let val = this.memory[this.mptr] - 1;\n\n          if (val < 0) {\n            val += MAX_CHAR_VALUE * (Math.ceil(-val / MAX_CHAR_VALUE))\n          }\n\n          this.memory[this.mptr] = val;\n          break;\n        case '.':\n          this.output += String.fromCharCode(this.memory[this.mptr]);\n          break;\n        case ',':\n          this.memory[this.mptr] = this.input.charCodeAt(0);\n\n          this.input = this.input.slice(1);\n          break;\n        case '[':\n          if (!this.memory[this.mptr]) {\n            this.iptr = jumpForward(this.program, this.iptr);\n          }\n          break;\n        case ']':\n          if (this.memory[this.mptr]) {\n            this.iptr = jumpBackward(this.program, this.iptr);\n          }\n          break;\n      }\n\n      this.iptr++;\n    }\n\n    const t2 = performance.now();\n\n    return {\n      program: this.program,\n      input: this.input,\n      output: this.output,\n      memory: this.memory,\n      compilationTime: t2 - t1,\n      infinite: this.infinite\n    };\n  }\n}\n\nmodule.exports = BrainFuck;\n"]}