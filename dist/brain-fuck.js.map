{"version":3,"sources":["../node_modules/process/browser.js","src/performance-now.coffee","utils/assert.js","constants/index.js","utils/jump.js","utils/santize-program.js","utils/converter.js","brain-fuck.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","assertString","str","trimLeft","assertNumber","num","assertObject","obj","constructor","assertArray","arr","MAX_CHAR_VALUE","EXTEND_SIZE","MEM_SIZE","BRAIN_FUCK_CONFIG","tokens","instructions","memoryPointerUp","memoryPointerDown","instructionPointerUp","instructionPointerDown","output","input","loopStart","loopEnd","wordCount","splitter","jumpForward","_iptr","openBracketsCount","iptr","slice","join","jumpBackward","closeBracketsCount","program","whitelistedWords","replace","split","filter","token","includes","from","to","table","forEach","ch","hasOwnProperty","Object","entries","key","value","BrainFuck","config","memory","fill","mptr","infinite","brainFuckConfig","assign","t1","fetchInstruction","val","Math","ceil","String","fromCharCode","charCodeAt","t2","compilationTime"],"mappings":"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","file":"brain-fuck.js","sourceRoot":"../src","sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","if performance? and performance.now\n  module.exports = -> performance.now()\nelse if process? and process.hrtime\n  module.exports = -> (getNanoSeconds() - nodeLoadTime) / 1e6\n  hrtime = process.hrtime\n  getNanoSeconds = ->\n    hr = hrtime()\n    hr[0] * 1e9 + hr[1]\n  moduleLoadTime = getNanoSeconds()\n  upTime = process.uptime() * 1e9\n  nodeLoadTime = moduleLoadTime - upTime\nelse if Date.now\n  module.exports = -> Date.now() - loadTime\n  loadTime = Date.now()\nelse\n  module.exports = -> new Date().getTime() - loadTime\n  loadTime = new Date().getTime()\n","export function assertString (str, name) {\n  if (typeof str !== 'string') {\n    throw new Error(`${name || ''} must be a string`.trimLeft());\n  }\n}\n\nexport function assertNumber (num, name) {\n  if (typeof num !== 'number') {\n    throw new Error(`${name || ''} must be a number`.trimLeft());\n  }\n}\n\nexport function assertObject (obj, name) {\n  if (!(obj && obj.constructor.name === 'Object')) {\n    throw new Error(`${name || ''} must be an object`.trimLeft());\n  }\n}\n\nexport function assertArray (arr, name) {\n  if (!(arr && arr.constructor.name === 'Array')) {\n    throw new Error(`${name || ''} must be an array`.trimLeft());\n  }\n}\n","const MAX_CHAR_VALUE = 256;\nconst EXTEND_SIZE = 10;\nconst MEM_SIZE = 300; // 300 cells\nconst BRAIN_FUCK_CONFIG = {\n  tokens: [\n    '>',\n    '<',\n    '+',\n    '-',\n    '.',\n    ',',\n    '[',\n    ']'\n  ],\n  instructions: {\n    memoryPointerUp: '>',\n    memoryPointerDown: '<',\n    instructionPointerUp: '+',\n    instructionPointerDown: '-',\n    output: '.',\n    input: ',',\n    loopStart: '[',\n    loopEnd: ']',\n  },\n  wordCount: 1,\n  splitter: ''\n};\n\nexport { BRAIN_FUCK_CONFIG, EXTEND_SIZE, MAX_CHAR_VALUE, MEM_SIZE };\n","import { assertArray, assertNumber, assertObject } from './assert'\n\nexport function jumpForward (tokens, _iptr, instructions = {}) {\n  assertArray(tokens, 'tokens');\n  assertNumber(_iptr, 'instruction pointer');\n  assertObject(instructions, 'instructions');\n\n  let iptr = _iptr, openBracketsCount = 1;\n\n  while (openBracketsCount > 0) {\n    iptr += instructions.wordCount;\n\n    switch (tokens.slice(iptr, iptr + instructions.wordCount).join(' ')) {\n      case instructions.loopStart:\n        openBracketsCount++;\n        break;\n      case instructions.loopEnd:\n        openBracketsCount--;\n        break;\n    }\n  }\n\n  return iptr;\n}\n\nexport function jumpBackward (tokens, _iptr, instructions) {\n  assertArray(tokens, 'tokens');\n  assertNumber(_iptr, 'instruction pointer');\n  assertObject(instructions, 'instructions');\n\n  let iptr = _iptr, closeBracketsCount = 1;\n\n  while (closeBracketsCount > 0) {\n    iptr -= instructions.wordCount;\n\n    switch (tokens.slice(iptr, iptr + instructions.wordCount).join(' ')) {\n      case instructions.loopEnd:\n        closeBracketsCount++;\n        break;\n      case instructions.loopStart:\n        closeBracketsCount--;\n        break;\n    }\n  }\n\n  return iptr;\n}\n","import { assertString, assertArray } from './assert';\n\nexport default function (program, splitter, whitelistedWords = []) {\n  assertString(program, 'program');\n  assertString(splitter, 'splitter');\n  assertArray(whitelistedWords, 'whitelisted words');\n\n  return program\n    .replace(/\\n/g, '')\n    .split(splitter)\n    .filter(token => whitelistedWords.includes(token));\n}\n","import { assertString, assertObject } from './assert'\n\nexport default function (program, splitter, from, to) {\n  assertString(program, 'program');\n  assertString(splitter, 'splitter');\n  assertObject(from, 'from');\n  assertObject(to, 'to');\n\n  let output = '';\n  const table = {};\n\n  program\n    .split('')\n    .forEach(ch => {\n      if (table.hasOwnProperty(ch)) {\n        output += to[table[ch]] + splitter;\n      } else {\n        for (const [key, value] of Object.entries(from)) {\n          if (value === ch) {\n            table[value] = key;\n            output += to[key] + splitter;\n            break;\n          }\n        }\n      }\n    });\n\n  return output;\n}\n","import now from 'performance-now';\nimport { assertString, assertObject } from './utils/assert';\nimport { BRAIN_FUCK_CONFIG, MAX_CHAR_VALUE, EXTEND_SIZE, MEM_SIZE } from './constants/index';\nimport { jumpBackward, jumpForward } from './utils/jump';\nimport sanitizeProgram from './utils/santize-program';\nimport converter from './utils/converter';\nclass BrainFuck {\n  constructor (program, input, config = {}) {\n    assertString(program, 'program');\n    assertObject(config, 'config');\n\n    this.program = program;\n    this.memory = Array(MEM_SIZE).fill(0);\n    this.input = input || '';\n    this.output = '';\n    this.iptr = 0; // instruction pointer\n    this.mptr = 0; // memory pointer\n    this.infinite = false;\n    this.brainFuckConfig = Object.assign({}, BRAIN_FUCK_CONFIG, config);\n  }\n\n  compile () {\n    const {\n      splitter,\n      tokens,\n      wordCount\n    } = this.brainFuckConfig;\n\n    this.tokens = sanitizeProgram(\n      this.program,\n      splitter,\n      tokens\n    );\n\n    if (!this.tokens.length) {\n      throw new Error('invalid program');\n    }\n\n    const {\n      memoryPointerUp,\n      memoryPointerDown,\n      instructionPointerUp,\n      instructionPointerDown,\n      output,\n      input,\n      loopStart,\n      loopEnd\n    } = this.brainFuckConfig.instructions;\n    const fetchInstruction = () => this.tokens.slice(this.iptr, this.iptr + wordCount).join(splitter);\n    const t1 = now();\n\n    while (this.iptr < this.tokens.length) {\n      if (now() - t1 > 20000) { // infinite detection, there might be a better way than this :)\n        this.infinite = true;\n        break;\n      }\n\n      switch (fetchInstruction()) {\n        case memoryPointerUp:\n          if (this.mptr >= this.memory.length - 1) {\n            this.memory = this.memory.concat(Array(EXTEND_SIZE).fill(0));\n          }\n\n          this.mptr++;\n          break;\n        case memoryPointerDown:\n          this.mptr = this.mptr - 1 < 0 ? this.mptr : this.mptr - 1;\n          break;\n        case instructionPointerUp:\n          this.memory[this.mptr] = (this.memory[this.mptr] + 1) % MAX_CHAR_VALUE;\n          break;\n        case instructionPointerDown:\n          let val = this.memory[this.mptr] - 1;\n\n          if (val < 0) {\n            val += MAX_CHAR_VALUE * (Math.ceil(-val / MAX_CHAR_VALUE))\n          }\n\n          this.memory[this.mptr] = val;\n          break;\n        case output:\n          this.output += String.fromCharCode(this.memory[this.mptr]);\n          break;\n        case input:\n          this.memory[this.mptr] = this.input.charCodeAt(0);\n          this.input = this.input.slice(1);\n          break;\n        case loopStart:\n          if (!this.memory[this.mptr]) {\n            this.iptr = jumpForward(this.tokens, this.iptr, {\n              loopStart,\n              loopEnd,\n              wordCount\n            });\n          }\n          break;\n        case loopEnd:\n          if (this.memory[this.mptr]) {\n            this.iptr = jumpBackward(this.tokens, this.iptr, {\n              loopStart,\n              loopEnd,\n              wordCount\n            });\n          }\n          break;\n      }\n\n      this.iptr += wordCount;\n    }\n\n    const t2 = now();\n\n    return {\n      program: this.program,\n      input: this.input,\n      output: this.output,\n      memory: this.memory,\n      compilationTime: t2 - t1,\n      infinite: this.infinite\n    };\n  }\n\n  /*\n  * kind of terrible at naming :(\n  * converts the given brainfuck to the custom brainfuck\n  * @param {string} program - any js program\n  * @param {object} config - config of custom brainfuck\n  * @returns {string}\n  *\n  * e.g.\n  *\n  * consider the given brainfuck that prints \"hello world\" to be converted to custom brainfuck\n  *\n  * program: +[-[<<[+[--->]-[<<<]]]>>>-]>-.---.>..>.<<<<-.<+.>>>>>.>.<<.<-.\n  *\n  * with the given config\n  *\n  * config: {\n  *   \"instructions\": {\n  *     \"instructionPointerUp\": \"oink. oink?\",\n  *     \"instructionPointerDown\": \"oink? oink.\",\n  *     \"memoryPointerUp\": \"oink. oink.\",\n  *     \"memoryPointerDown\": \"oink! oink!\",\n  *     \"input\": \"\",\n  *     \"output\": \"oink! oink.\",\n  *     \"loopStart\": \"oink! oink?\",\n  *     \"loopEnd\": \"oink? oink!\"\n  *   },\n  *   \"splitter\": \" \"\n  * }\n  *\n  * expected output\n  *\n  * oink. oink? oink! oink? oink? oink. oink! oink? oink! oink! oink! oink! oink! oink? oink. oink? oink! oink? oink?\n  * oink. oink? oink. oink? oink. oink. oink. oink? oink! oink? oink. oink! oink? oink! oink! oink! oink! oink! oink!\n  * oink? oink! oink? oink! oink? oink! oink. oink. oink. oink. oink. oink. oink? oink. oink? oink! oink. oink. oink?\n  * oink. oink! oink. oink? oink. oink? oink. oink? oink. oink! oink. oink. oink. oink! oink. oink! oink. oink. oink.\n  * oink! oink. oink! oink! oink! oink! oink! oink! oink! oink! oink? oink. oink! oink. oink! oink! oink. oink? oink!\n  * oink. oink. oink. oink. oink. oink. oink. oink. oink. oink. oink. oink! oink. oink. oink. oink! oink. oink! oink!\n  * oink! oink! oink! oink. oink! oink! oink? oink. oink! oink.\n  */\n\n  static convert (program, config) {\n    assertString(program, 'program');\n    assertObject(config, 'config');\n\n    return converter(\n      program,\n      config.splitter,\n      BRAIN_FUCK_CONFIG.instructions,\n      config.instructions\n    );\n  }\n}\n\nmodule.exports = BrainFuck;\n"]}