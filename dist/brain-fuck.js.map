{"version":3,"sources":["utils/assert.js","constants/index.js","utils/jump.js","utils/santize-program.js","utils/converter.js","brain-fuck.js"],"names":["assertString","str","name","Error","trimLeft","assertNumber","num","assertObject","obj","constructor","assertArray","arr","MAX_CHAR_VALUE","EXTEND_SIZE","MEM_SIZE","BRAIN_FUCK_CONFIG","tokens","instructions","memoryPointerRight","memoryPointerLeft","instructionPointerIncrement","instructionPointerDecrement","output","input","loopStart","loopEnd","wordCount","splitter","jumpForward","_iptr","openBracketsCount","iptr","slice","join","jumpBackward","closeBracketsCount","program","whitelistedWords","replace","split","filter","token","includes","from","to","table","forEach","ch","hasOwnProperty","Object","entries","key","value","BrainFuck","config","memory","Array","fill","mptr","infinite","brainFuckConfig","assign","length","t1","performance","now","fetchInstruction","concat","val","Math","ceil","String","fromCharCode","charCodeAt","t2","compilationTime","module","exports"],"mappings":"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","file":"brain-fuck.js","sourceRoot":"../src","sourcesContent":["export function assertString (str, name) {\n  if (typeof str !== 'string') {\n    throw new Error(`${name || ''} must be a string`.trimLeft());\n  }\n}\n\nexport function assertNumber (num, name) {\n  if (typeof num !== 'number') {\n    throw new Error(`${name || ''} must be a number`.trimLeft());\n  }\n}\n\nexport function assertObject (obj, name) {\n  if (!(obj && obj.constructor.name === 'Object')) {\n    throw new Error(`${name || ''} must be an object`.trimLeft());\n  }\n}\n\nexport function assertArray (arr, name) {\n  if (!(arr && arr.constructor.name === 'Array')) {\n    throw new Error(`${name || ''} must be an array`.trimLeft());\n  }\n}\n","const MAX_CHAR_VALUE = 256;\nconst EXTEND_SIZE = 10;\nconst MEM_SIZE = 300; // 300 cells\nconst BRAIN_FUCK_CONFIG = {\n  tokens: [\n    '>',\n    '<',\n    '+',\n    '-',\n    '.',\n    ',',\n    '[',\n    ']'\n  ],\n  instructions: {\n    memoryPointerRight: '>',\n    memoryPointerLeft: '<',\n    instructionPointerIncrement: '+',\n    instructionPointerDecrement: '-',\n    output: '.',\n    input: ',',\n    loopStart: '[',\n    loopEnd: ']',\n  },\n  wordCount: 1,\n  splitter: ''\n};\n\nexport { BRAIN_FUCK_CONFIG, EXTEND_SIZE, MAX_CHAR_VALUE, MEM_SIZE };\n","import { assertArray, assertNumber, assertObject } from './assert'\n\nexport function jumpForward (tokens, _iptr, instructions = {}) {\n  assertArray(tokens, 'tokens');\n  assertNumber(_iptr, 'instruction pointer');\n  assertObject(instructions, 'instructions');\n\n  let iptr = _iptr, openBracketsCount = 1;\n\n  while (openBracketsCount > 0) {\n    iptr += instructions.wordCount;\n\n    switch (tokens.slice(iptr, iptr + instructions.wordCount).join(' ')) {\n      case instructions.loopStart:\n        openBracketsCount++;\n        break;\n      case instructions.loopEnd:\n        openBracketsCount--;\n        break;\n    }\n  }\n\n  return iptr;\n}\n\nexport function jumpBackward (tokens, _iptr, instructions) {\n  assertArray(tokens, 'tokens');\n  assertNumber(_iptr, 'instruction pointer');\n  assertObject(instructions, 'instructions');\n\n  let iptr = _iptr, closeBracketsCount = 1;\n\n  while (closeBracketsCount > 0) {\n    iptr -= instructions.wordCount;\n\n    switch (tokens.slice(iptr, iptr + instructions.wordCount).join(' ')) {\n      case instructions.loopEnd:\n        closeBracketsCount++;\n        break;\n      case instructions.loopStart:\n        closeBracketsCount--;\n        break;\n    }\n  }\n\n  return iptr;\n}\n","import { assertString, assertArray } from './assert';\n\nexport default function (program, splitter, whitelistedWords = []) {\n  assertString(program, 'program');\n  assertString(splitter, 'splitter');\n  assertArray(whitelistedWords, 'whitelisted words');\n\n  return program\n    .replace(/\\n/g, '')\n    .split(splitter)\n    .filter(token => whitelistedWords.includes(token));\n}\n","import { assertString, assertObject } from './assert'\n\nexport default function (program, splitter, from, to) {\n  assertString(program, 'program');\n  assertString(splitter, 'splitter');\n  assertObject(from, 'from');\n  assertObject(to, 'to');\n\n  let output = '';\n  const table = {};\n\n  program\n    .split('')\n    .forEach(ch => {\n      if (table.hasOwnProperty(ch)) {\n        output += to[table[ch]] + splitter;\n      } else {\n        for (const [key, value] of Object.entries(from)) {\n          if (value === ch) {\n            table[value] = key;\n            output += to[key] + splitter;\n            break;\n          }\n        }\n      }\n    });\n\n  return output;\n}\n","import { assertString, assertObject } from './utils/assert';\nimport { BRAIN_FUCK_CONFIG, MAX_CHAR_VALUE, EXTEND_SIZE, MEM_SIZE } from './constants/index';\nimport { jumpBackward, jumpForward } from './utils/jump';\nimport sanitizeProgram from './utils/santize-program';\nimport converter from './utils/converter';\nclass BrainFuck {\n  constructor (program, input, config = {}) {\n    assertString(program, 'program');\n    assertObject(config, 'config');\n\n    this.program = program;\n    this.memory = Array(MEM_SIZE).fill(0);\n    this.input = input || '';\n    this.output = '';\n    this.iptr = 0; // instruction pointer\n    this.mptr = 0; // memory pointer\n    this.infinite = false;\n    this.brainFuckConfig = Object.assign({}, BRAIN_FUCK_CONFIG, config);\n  }\n\n  compile () {\n    const {\n      splitter,\n      tokens,\n      wordCount\n    } = this.brainFuckConfig;\n\n    this.tokens = sanitizeProgram(\n      this.program,\n      splitter,\n      tokens\n    );\n\n    if (!this.tokens.length) {\n      throw new Error('invalid program');\n    }\n\n    const {\n      memoryPointerRight,\n      memoryPointerLeft,\n      instructionPointerIncrement,\n      instructionPointerDecrement,\n      output,\n      input,\n      loopStart,\n      loopEnd\n    } = this.brainFuckConfig.instructions;\n    const fetchInstruction = () => this.tokens.slice(this.iptr, this.iptr + wordCount).join(splitter);\n    const t1 = performance.now();\n\n    while (this.iptr < this.tokens.length) {\n      if (performance.now() - t1 > 20000) { // infinite detection, there might be a better way than this :)\n        this.infinite = true;\n        break;\n      }\n\n      switch (fetchInstruction()) {\n        case memoryPointerRight:\n          if (this.mptr >= this.memory.length - 1) {\n            this.memory = this.memory.concat(Array(EXTEND_SIZE).fill(0));\n          }\n\n          this.mptr++;\n          break;\n        case memoryPointerLeft:\n          this.mptr = this.mptr - 1 < 0 ? this.mptr : this.mptr - 1;\n          break;\n        case instructionPointerIncrement:\n          this.memory[this.mptr] = (this.memory[this.mptr] + 1) % MAX_CHAR_VALUE;\n          break;\n        case instructionPointerDecrement:\n          let val = this.memory[this.mptr] - 1;\n\n          if (val < 0) {\n            val += MAX_CHAR_VALUE * (Math.ceil(-val / MAX_CHAR_VALUE))\n          }\n\n          this.memory[this.mptr] = val;\n          break;\n        case output:\n          this.output += String.fromCharCode(this.memory[this.mptr]);\n          break;\n        case input:\n          this.memory[this.mptr] = this.input.charCodeAt(0);\n          this.input = this.input.slice(1);\n          break;\n        case loopStart:\n          if (!this.memory[this.mptr]) {\n            this.iptr = jumpForward(this.tokens, this.iptr, {\n              loopStart,\n              loopEnd,\n              wordCount\n            });\n          }\n          break;\n        case loopEnd:\n          if (this.memory[this.mptr]) {\n            this.iptr = jumpBackward(this.tokens, this.iptr, {\n              loopStart,\n              loopEnd,\n              wordCount\n            });\n          }\n          break;\n      }\n\n      this.iptr += wordCount;\n    }\n\n    const t2 = performance.now();\n\n    return {\n      program: this.program,\n      input: this.input,\n      output: this.output,\n      memory: this.memory,\n      compilationTime: t2 - t1,\n      infinite: this.infinite\n    };\n  }\n\n  convert (program) {\n    assertString(program, 'program');\n\n    return converter(\n      program,\n      this.brainFuckConfig.splitter,\n      BRAIN_FUCK_CONFIG.instructions,\n      this.brainFuckConfig.instructions\n    );\n  }\n}\n\nmodule.exports = BrainFuck;\n"]}